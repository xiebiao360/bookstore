// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/gin-gonic/gin"
	"github.com/google/wire"
	redis2 "github.com/redis/go-redis/v9"
	"github.com/swaggo/files"
	"github.com/swaggo/gin-swagger"
	book2 "github.com/xiebiao/bookstore/internal/application/book"
	"github.com/xiebiao/bookstore/internal/application/order"
	user2 "github.com/xiebiao/bookstore/internal/application/user"
	"github.com/xiebiao/bookstore/internal/domain/book"
	"github.com/xiebiao/bookstore/internal/domain/user"
	"github.com/xiebiao/bookstore/internal/infrastructure/config"
	"github.com/xiebiao/bookstore/internal/infrastructure/persistence/mysql"
	"github.com/xiebiao/bookstore/internal/infrastructure/persistence/redis"
	"github.com/xiebiao/bookstore/internal/interface/http/handler"
	"github.com/xiebiao/bookstore/internal/interface/http/middleware"
	"github.com/xiebiao/bookstore/pkg/jwt"
)

import (
	_ "github.com/xiebiao/bookstore/docs"
	_ "net/http/pprof"
)

// Injectors from wire.go:

// InitializeApp 初始化整个应用
// 返回：配置好的Gin引擎
// 错误：如果任何依赖创建失败
//
// 教学说明：
// Wire Injector函数的返回值有限制：
// - 第一个返回值：要构造的目标类型（*gin.Engine）
// - 第二个返回值（可选）：只能是error或cleanup函数
// - 不能返回多个业务对象，如果需要Config可以在provideGinEngine中处理
func InitializeApp() (*gin.Engine, error) {
	configConfig, err := config.Load()
	if err != nil {
		return nil, err
	}
	db, err := mysql.NewDB(configConfig)
	if err != nil {
		return nil, err
	}
	repository := mysql.NewUserRepository(db)
	service := user.NewService(repository)
	registerUseCase := user2.NewRegisterUseCase(service)
	manager := provideJWTManager(configConfig)
	client, err := redis.NewClient(configConfig)
	if err != nil {
		return nil, err
	}
	sessionStore := provideSessionStore(client)
	loginUseCase := user2.NewLoginUseCase(service, manager, sessionStore)
	userHandler := handler.NewUserHandler(registerUseCase, loginUseCase)
	bookRepository := mysql.NewBookRepository(db)
	bookService := book.NewService(bookRepository)
	publishBookUseCase := book2.NewPublishBookUseCase(bookService)
	listBooksUseCase := book2.NewListBooksUseCase(bookService)
	bookHandler := handler.NewBookHandler(publishBookUseCase, listBooksUseCase)
	orderRepository := mysql.NewOrderRepository(db)
	txManager := mysql.NewTxManager(db)
	createOrderUseCase := order.NewCreateOrderUseCase(orderRepository, bookRepository, txManager)
	orderHandler := handler.NewOrderHandler(createOrderUseCase)
	authMiddleware := middleware.NewAuthMiddleware(manager, sessionStore)
	engine := provideGinEngine(configConfig, userHandler, bookHandler, orderHandler, authMiddleware)
	return engine, nil
}

// wire.go:

// infrastructureSet 基础设施层依赖
// 包含：配置加载、数据库连接、Redis连接
var infrastructureSet = wire.NewSet(config.Load, mysql.NewDB, redis.NewClient)

// repositorySet 仓储层依赖
// 包含：所有Repository的构造函数
var repositorySet = wire.NewSet(mysql.NewUserRepository, mysql.NewBookRepository, mysql.NewOrderRepository, mysql.NewTxManager)

// domainSet 领域层依赖
// 包含：所有领域服务的构造函数
var domainSet = wire.NewSet(user.NewService, book.NewService)

// applicationSet 应用层依赖
// 包含：所有Use Case的构造函数
var applicationSet = wire.NewSet(user2.NewRegisterUseCase, user2.NewLoginUseCase, book2.NewPublishBookUseCase, book2.NewListBooksUseCase, order.NewCreateOrderUseCase)

// middlewareSet 中间件依赖
// 包含：JWT管理器、认证中间件
var middlewareSet = wire.NewSet(
	provideJWTManager,
	provideSessionStore, middleware.NewAuthMiddleware,
)

// handlerSet HTTP处理器依赖
// 包含：所有Handler的构造函数
var handlerSet = wire.NewSet(handler.NewUserHandler, handler.NewBookHandler, handler.NewOrderHandler)

// provideJWTManager 从配置创建JWT管理器
// 教学要点：config.Config 包含多个字段，但jwt.NewManager只需要JWT相关的配置
// Wire无法自动知道如何从Config提取参数，所以需要手动编写Provider
func provideJWTManager(cfg *config.Config) *jwt.Manager {
	return jwt.NewManager(
		cfg.JWT.Secret,
		cfg.JWT.AccessTokenExpire,
		cfg.JWT.RefreshTokenExpire,
	)
}

// provideSessionStore 从Redis客户端创建Session存储
// 教学要点：redis.NewSessionStore需要*goredis.Client参数
// Wire会自动注入redis.NewClient()的返回值
func provideSessionStore(client *redis2.Client) *redis.SessionStore {
	return redis.NewSessionStore(client)
}

// provideGinEngine 创建并配置Gin引擎
// 教学要点：
// 1. Gin引擎需要注册所有路由
// 2. 路由注册需要所有的Handler和Middleware
// 3. Wire会自动注入这些依赖
// 4. 这里直接在函数内注册路由，避免与main.go中的registerRoutes函数冲突
func provideGinEngine(
	cfg *config.Config,
	userHandler *handler.UserHandler,
	bookHandler *handler.BookHandler,
	orderHandler *handler.OrderHandler,
	authMiddleware *middleware.AuthMiddleware,
) *gin.Engine {

	if cfg.Server.Mode == "release" {
		gin.SetMode(gin.ReleaseMode)
	}

	r := gin.Default()

	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
			"status":  "healthy",
		})
	})

	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	v1 := r.Group("/api/v1")
	{

		users := v1.Group("/users")
		{
			users.POST("/register", userHandler.Register)
			users.POST("/login", userHandler.Login)
		}

		authorized := v1.Group("")
		authorized.Use(authMiddleware.RequireAuth())
		{

			authorized.GET("/profile", func(c *gin.Context) {
				userID := middleware.GetUserID(c)
				email := middleware.GetEmail(c)
				c.JSON(200, gin.H{
					"user_id": userID,
					"email":   email,
					"message": "这是需要登录才能访问的接口",
				})
			})
		}

		books := v1.Group("/books")
		{

			books.GET("", bookHandler.ListBooks)

			books.POST("", authMiddleware.RequireAuth(), bookHandler.PublishBook)
		}

		orders := v1.Group("/orders")
		orders.Use(authMiddleware.RequireAuth())
		{
			orders.POST("", orderHandler.CreateOrder)
		}
	}

	return r
}
